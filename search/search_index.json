{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Setup","text":""},{"location":"#basic","title":"Basic","text":"<pre><code>apt update -y\napt upgrade -y\napt install -y vim curl wget\n</code></pre>"},{"location":"#create-user","title":"Create User","text":"<pre><code>adduser &lt;username&gt;\nusermod -aG sudo,admin &lt;username&gt;\n</code></pre>"},{"location":"#ssh-configuration","title":"SSH-Configuration","text":"<p>Insert your <code>ssh-public-keys</code> in ~/.ssh/authorized_keys.</p> <p>Then change your <code>ssh</code>-Port to 2222:</p> <pre><code>sudo vim /etc/ssh/sshd_config\n# Search for the line with `Port 22`\n# Uncomment it and change it to `Port 2222`\nservice ssh restart\n</code></pre> <p>Now you have to relog.</p>"},{"location":"#install-docker-and-docker-compose","title":"Install Docker and Docker-Compose","text":"<p>Execute the <code>docker</code>-Install Script:</p> <pre><code>curl -fsSL https://get.docker.com | sudo bash\n</code></pre> <p>After this installation you will see a comment which suggests you to install <code>docker-rootless</code> but I do not recommend to do this.</p> <p>Now you have to install <code>docker-compose</code>:</p> <pre><code>sudo curl -L -o /usr/local/bin/docker-compose \\\n\"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\"\nsudo chmod +x /usr/local/bin/docker-compose\n</code></pre> <p>Then create some aliases:</p> <pre><code>cat &lt;&lt;_EOF &gt;&gt; .bashrc\nalias dc='sudo docker-compose'\nalias docker='sudo docker'\nalias dcr='sudo docker-compose down &amp;&amp; sudo docker-compose up -d'\n_EOF\n</code></pre> <p>Last but not least create a network for <code>docker</code>:</p> <pre><code>sudo docker network create --subnet 172.20.255.0/24 database\nsudo docker network create --subnet 172.30.255.0/24 matrix\n</code></pre>"},{"location":"0_proxy/","title":"Proxy","text":""},{"location":"0_proxy/#install","title":"Install","text":"<p>In this configuration we will use <code>nginx</code> as reverse-proxy. First of all install <code>nginx-full</code>:</p> <pre><code>sudo apt install nginx-full\n</code></pre> <p>Then add an alias to reload your proxy:</p> <pre><code>cat &lt;&lt;_EOF &gt;&gt; .bashrc\nalias ngr='sudo nginx -t &amp;&amp; sudo systemctl reload nginx'\n_EOF\n</code></pre> <p>Put this in your <code>/etc/nginx/sites-available/default</code> to redirect to <code>https</code> by default:</p> <pre><code>server {\nlisten 80 default_server;\nlisten [::]:80 default_server;\nserver_name _;\nreturn 301 https://$host$request_uri;\n}\n</code></pre>"},{"location":"0_proxy/#ssl-certificates","title":"SSL Certificates","text":"<p>For securing our sites we use <code>.acme.sh</code>. Install it and run some additional commands:</p> <pre><code>curl https://get.acme.sh | sh -s email=certs@domain.tld # You probably do not need a Mailserver for this\nsudo ln -s ~/.acme.sh/acme.sh /usr/bin/acme.sh # Relog\nacme.sh --install-cronjob\n</code></pre> <p>To issue a certificate run following command:</p> <pre><code>acme.sh --issue --keylength ec-384 --dns dns_cf -d subdomain.domain.tld\n</code></pre> <p>The certificate will be generated in <code>~/.acme.sh/subdomain.domain.tld_ecc</code>. Move this folder to <code>~/.acme.sh/subdomain.domain.tld</code>.</p>"},{"location":"0_proxy/#service-template","title":"Service Template","text":"<p>Create a folder for your service or your service stack and create a <code>docker-compose.yaml</code>:</p> <pre><code>version: '3.9'\nservices:\nservice:\n[ ... ]\nports:\n- \"[::1]:8000:&lt;container_port&gt;\"\n</code></pre> <p>Issue a certificate for your website as I mentioned earlier and create a VHost-File like this:</p> <pre><code>server {\nserver_name subdomain.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/&lt;username&gt;/.acme.sh/subdomain.domain.tld/fullchain.cer;\nssl_certificate_key /home/&lt;username&gt;/.acme.sh/subdomain.domain.tld/subdomain.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation / {\nproxy_pass http://[::1]:8000/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n}\n</code></pre> <p>Link your VHost-File and reload:</p> <pre><code>sudo ln -s /etc/nginx/sites-available/subdomain.domain.tld /etc/nginx/sites-enabled/\nngr\n</code></pre>"},{"location":"1_additional_configs/","title":"Additional Configs (Optional)","text":""},{"location":"1_additional_configs/#mount-samba-file-storage","title":"Mount Samba File Storage","text":"<p>In this expample with: <code>Hetzner Storage Box</code></p>"},{"location":"1_additional_configs/#install-dependencies","title":"Install Dependencies","text":"<p>You have to install the <code>cifs-utils</code>-Package.</p> <pre><code>sudo apt install cifs-utils\n</code></pre>"},{"location":"1_additional_configs/#create-storage-destination-folder","title":"Create Storage Destination Folder","text":"<p>Now you create the folder where your files and your data should be saved to.</p> <pre><code>sudo mkdir /media/share\n# OR\nsudo mkdir /srv/minio\n# To use it directly as storage for MinIO\n</code></pre>"},{"location":"1_additional_configs/#set-credentials","title":"Set Credentials","text":"<p>The credentials used to connect to the samba file share have to be written in to a file.</p> <pre><code>sudo cat &lt;&lt;_EOF &gt;&gt; /root/.sbcredentials\nusername=STORAGE-BOX-USERNAME\npassword=STORAGE-BOX-PASSWORD\n_EOF\n\nsudo chmod 400 /root/.sbcredentials\n</code></pre>"},{"location":"1_additional_configs/#mount","title":"Mount","text":"<pre><code>sudo mount -t cifs -o rw,vers=3.0,credentials=/root/.examplecredentials //username.your-storagebox.de/(backup|sub-account-name) (/media/share|/srv/minio)\n</code></pre> <p>If there are no errors you may add this line to your <code>/etc/fstab</code>:</p> <pre><code>//username.your-storagebox.de/(backup|sub-account-name) (/media/share|/srv/minio) cifs vers=3.0,credentials=/root/.examplecredentials\n</code></pre> <p>And finally you're done.</p>"},{"location":"services/coder/","title":"Coder","text":"<p>Coder is an Open Source solution as an equivalent to Github Codespaces. You do not need to pay anything than your server.</p>"},{"location":"services/coder/#docker","title":"Docker","text":"<p>To setup a Coder instance your <code>docker-compose.yaml</code> should look like this:</p> <pre><code>version: '3.9'\nservices:\ncoder:\nimage: ghcr.io/coder/coder:latest\nrestart: always\nenv_file: .coder.env\nports:\n- \"[::1]:8012:7080\"\nvolumes:\n- \"/var/run/docker.sock:/var/run/docker.sock\"\nnetworks:\n- database\ngroup_add:\n- \"999\"\nnetworks:\ndatabase:\nname: database\nexternal: true\n</code></pre> <p>The flag under <code>group_add</code> has to be the Docker GroupID. The <code>.env</code> file should the following content:</p> <pre><code># .coder.env\nCODER_PG_CONNECTION_URL=postgresql://&lt;username&gt;:&lt;password&gt;@postgres:5432/&lt;database&gt;?sslmode=disable\nCODER_ADDRESS=0.0.0.0:7080\nCODER_ACCESS_URL=https://coder.domain.tld\nCODER_WILDCARD_ACCESS_URL=https://*.coder.domain.tld # This is for the internal portforwarding. If you don't want to use this you just remove this key.\n</code></pre>"},{"location":"services/coder/#nginx","title":"Nginx","text":"<p>Issue a certificate for your domain and create your VHost-File:</p> <pre><code># https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=modern&amp;openssl=1.1.1d&amp;guideline=5.6\nserver {\nserver_name coder.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/&lt;username&gt;/.acme.sh/coder.domain.tld/fullchain.cer;\nssl_certificate_key /home/&lt;username&gt;/.acme.sh/coder.domain.tld/coder.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation / {\nproxy_pass http://[::1]:8012/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n} </code></pre>"},{"location":"services/coder/#port-forwarding","title":"Port forwarding","text":"<p>The Coder Port Forwarding is currently not working. If you want you can do this configuration anyway.</p> <p>If you need this append the following line to your <code>.env</code>-File:</p> <pre><code>CODER_WILDCARD_ACCESS_URL=*.coder.domain.tld\n</code></pre> <p>The command to issue your certificate is now:</p> <pre><code>acme.sh --issue --keylength ec-384 --dns dns_cf -d coder.domain.tld -d *.coder.domain.tld\n</code></pre> <p>And you also have to create a DNS-Record named <code>*.coder.domain.tld</code> pointing to <code>coder.domain.tld</code></p>"},{"location":"services/core/","title":"Core","text":"<p>The core project is currently not in development</p> <p>The core-project is a web app which has no specific use case. To set it up correctly you first have to create a <code>docker-compose.yaml</code>:</p> <pre><code>version: \"3.9\"\nservices:\ncore:\nimage: ghcr.io/feluxerich/core:latest\nenv_file: .core.env\nports:\n- \"[::1]:8004:3000\"\nvolumes:\n- \"./.core.env:/app/.env\"\n</code></pre> <p>After that create a <code>.env</code>-File. As you may have seen above you have to name it <code>.core.env</code>. In this file you have to set the following values:</p> <pre><code>MONGO_URI=\"&lt;mongodb connection uri&gt;\"\nJWT_SECRET_KEY=\"SUPER_SECRET_KEY\"\nNEXT_PUBLIC_BASE_URL=\"https://domain.tld\"\n</code></pre> <p>Now you are ready to fire up the container.</p>"},{"location":"services/hedgedoc/","title":"Hedgedoc","text":"<p>Hedgedoc is a collaborative markdown editing tool. To set up Hedgedoc create a <code>docker-compose.yaml</code> like this:</p> <pre><code>version: '3.9'\nservices:\nhedgedoc:\nimage: quay.io/hedgedoc/hedgedoc\nrestart: always\nenv_file: .hedgedoc.env\nvolumes:\n- \"/srv/hedgedoc/uploads:/hedgedoc/public/uploads\"\nnetworks:\n- database\nports:\n- \"[::1]:8001:3000\"\nnetworks:\ndatabase:\nname: database\nexternal: true\n</code></pre> <p>As you may see in the configuration you also need a <code>.env</code>-File. This should look like this:</p> <pre><code># .hedgedoc.env\nCMD_DB_URL=postgres://&lt;username&gt;:&lt;password&gt;@postgres:5432/&lt;database&gt;\nCMD_DOMAIN=md.domain.tld\nCMD_PROTOCOL_USESSL=true\nCMD_URL_ADDPORT=false\n\nCMD_EMAIL=false\nCMD_ALLOW_EMAIL_REGISTER=false\n\nCMD_ALLOW_FREEURL=true\nCMD_REQUIRE_FREEURL_AUTHENTICATION=true\n\nCMD_GITHUB_CLIENTID=&lt;github_oauth_id&gt;\nCMD_GITHUB_CLIENTSECRET=&lt;github_oauth_secret&gt;\n\nCMD_ALLOW_ANONYMOUS=false\nCMD_ALLOW_ANONYMOUS_EDITS=true\n\nCMD_SESSION_SECRET=&lt;session_secret&gt;\n</code></pre> <p>If you want to create a new note with a custom alias you can just open the editor with a Custom-Aliased-URL. To prevent not authenticated users to create a bunch of trash notes you have to be signed in to do this.</p> <p>In this configuration only the authentication with Github is possible but if you want to allow local users via email you have to remove the line that says <code>CMD_EMAIL=false</code> and create the accounts manually using the <code>bin/manage_users</code>-Script in the container.</p> <p>When you have done this start your container with <code>dc up -d</code>, issue a certificate and create a VHost-File containing something like this:</p> <pre><code># https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=modern&amp;openssl=1.1.1d&amp;guideline=5.6\nserver {\nserver_name md.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/&lt;username&gt;/.acme.sh/md.domain.tld/fullchain.cer;\nssl_certificate_key /home/&lt;username&gt;/.acme.sh/md.domain.tld/md.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation / {\nproxy_pass http://[::1]:8001/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n}\n</code></pre>"},{"location":"services/matrix/","title":"Matrix","text":"<p>We will create a matrix server which usernames look like <code>@username:domain.tld</code>. For this we need to host <code>.well-known</code> config, or we do this in the <code>nginx</code>-Config. Put this in your <code>/etc/nginx/sites-available/domain.tld</code>:</p>"},{"location":"services/matrix/#well-known","title":".well-known","text":"<pre><code># https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=modern&amp;openssl=1.1.1d&amp;guideline=5.6\nserver {\nserver_name domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\n[...]\n\nlocation = /.well-known/matrix/server {\ndefault_type application/json;\nadd_header Access-Control-Allow-Origin *;\nreturn 200 '{\"m.server\": \"synapse.domain.tld:443\"}';\n}\nlocation = /.well-known/matrix/client {\ndefault_type application/json;\nadd_header Access-Control-Allow-Origin *;\nreturn 200 '{\"m.homeserver\":{\"base_url\":\"https://synapse.domain.tld/\"}}';\n}\n}\n</code></pre>"},{"location":"services/matrix/#configuration","title":"Configuration","text":"<p>For this configuration we use Postgres as database instead of SQLite. To create the right database for matrix execute this command in <code>psql</code>:</p> <pre><code>CREATE USER matrix WITH PASSWORD '&lt;securepassword&gt;';\nCREATE DATABASE matrix OWNER matrix LOCALE 'C' TEMPLATE 'template0';\n</code></pre> <p>To create the <code>homeserver.yaml</code> and some other configuration files for our homeserver run this command:</p> <pre><code>docker run -it --rm -v \"/srv/matrix/synapse:/data\" -e \"SYNAPSE_SERVER_NAME=domain.tld\" -e \"SYNAPSE_REPORT_STATS=no\" matrixdotorg/synapse generate\n</code></pre> <p>Now go to <code>/srv/matrix/synapse/homeserver.yaml</code>. Look for the lines:</p> <pre><code>database:\nname: sqlite3\nargs:\ndatabase: /data/homeserver.db\n</code></pre> <p>and replace them with</p> <pre><code>database:\nname: psycopg2\nargs:\nuser: matrix\npassword: &lt;securepassword&gt;\ndatabase: matrix\nhost: postgres\ncp_min: 5\ncp_max: 10\n</code></pre>"},{"location":"services/matrix/#nginx","title":"Nginx","text":"<p>Do not forget to issue a certificate for <code>synapse.domain.tld</code></p> <pre><code># https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=modern&amp;openssl=1.1.1d&amp;guideline=5.6\nserver {\nserver_name synapse.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/felix/.acme.sh/synapse.domain.tld/fullchain.cer;\nssl_certificate_key /home/felix/.acme.sh/synapse.domain.tld/synapse.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation ~ ^(/_matrix|/_synapse/client) { # You have to do it this way otherwise matrix will throw you singin errors\nproxy_pass http://[::1]:8000;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n}\n</code></pre>"},{"location":"services/matrix/#federation","title":"Federation","text":"<p>Create a <code>srv</code>-Record in your DNS-Settings:</p> <pre><code>;; SRV Records\n_matrix._tcp.synapse.domain.tld.    1    IN    SRV    10 5 443 synapse.domain.tld.\n</code></pre>"},{"location":"services/matrix/#docker","title":"Docker","text":"<p>This is the <code>docker-compose.yaml</code> for this configuration:</p> <pre><code>version: '3.9'\n\nservices:\nsynapse:\nimage: matrixdotorg/synapse\nrestart: always\nvolumes:\n- \"/srv/matrix/synapse:/data\"\nnetworks:\n- database\n- matrix\nports:\n- \"[::1]:8000:8008\"\nnetworks:\ndatabase:\nname: database\nexternal: true\nmatrix:\nname: matrix\nexternal: true\n</code></pre> <p>Run <code>dc up -d</code>.</p>"},{"location":"services/matrix/#users","title":"Users","text":"<p>To create users use the command:</p> <pre><code>dc exec synapse register_new_matrix_user -u &lt;username&gt; -p &lt;password&gt; -a -c /data/homeserver.yaml https://synapse.domain.tld\n# or this one to see command reference\ndc exec synapse register_new_matrix_user -a -c /data/homeserver.yaml https://synapse.domain.tld --help\n</code></pre>"},{"location":"services/minio/","title":"MinIO","text":"<p>If you want to setup MinIO your first step should be to check if you have enough storage for whatever you want to do. Maybe you want to mount a Samba File Share to save your MinIO Data on it. Then you can create a <code>docker-compose.yaml</code>-file like this:</p> <pre><code>version: '3.9'\nservices:\nminio:\nimage: quay.io/minio/minio\nenv_file: .minio.env\ncommand: server /data --console-address \":9090\"\nports:\n- \"[::1]:8002:9090\"\n- \"9000:9000\"\nvolumes:\n- \"/srv/minio:/data\"\n</code></pre> <p>If you now look at your created <code>docker-compose.yaml</code> you may see that a <code>.minio.env</code>-file is required. In this you have to put the following content:</p> <pre><code># .minio.env\nMINIO_ROOT_USER=admin\nMINIO_ROOT_PASSWORD=YOUR-SUPER-SECRET-PASSWORD\n</code></pre> <p>When you have done this start your container with <code>dc up -d</code>, issue a certificate and create a VHost-File containing something like this:</p> <pre><code># https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=modern&amp;openssl=1.1.1d&amp;guideline=5.6\nserver {\nserver_name minio.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/&lt;username&gt;/.acme.sh/minio.domain.tld/fullchain.cer;\nssl_certificate_key /home/&lt;username&gt;/.acme.sh/minio.domain.tld/minio.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation / {\nproxy_pass http://[::1]:8002/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n}\n</code></pre> <p>And you are done. Congratulations!</p>"},{"location":"services/mongodb/","title":"MongoDB","text":"<p>Create <code>docker-compose.yaml</code> and your <code>.env</code>-File:</p> <pre><code>version: '3.9'\n\nservices:\nmongodb:\nimage: mongo\nrestart: always\nenv_file: .mongodb.env\nports:\n- \"27017:27017\"\nvolumes:\n- \"/etc/localtime:/etc/localtime:ro\"\n- \"/srv/mongodb/data:/data/db\"\nnetworks:\n- database\nnetworks:\ndatabase:\nname: database\nexternal: true\n</code></pre> <pre><code># .mongodb.env\nMONGO_INITDB_ROOT_USERNAME=root\nMONGO_INITDB_ROOT_PASSWORD=&lt;password&gt;\n</code></pre> <p>Now you have set up MongoDB.</p>"},{"location":"services/postgres/","title":"Postgres","text":"<p>Create <code>docker-compose.yaml</code>:</p> <pre><code>version: '3.9'\n\nservices:\npostgres:\nimage: postgres\nrestart: always\nenv_file: .postgres.env\nvolumes:\n- \"/srv/postgres:/var/lib/postgresql/data\"\nnetworks:\n- database\nnetworks:\ndatabase:\nname: database\nexternal: true\n</code></pre> <p>And your <code>.env</code>-File:</p> <pre><code># .postgres.env\nPOSTGRES_USER=root\nPOSTGRES_PASSWORD=&lt;password&gt;\nPOSTGRES_DB=postgres\n</code></pre> <p>Then just run <code>dc up -d</code> and you have your own PostgreSQL.</p>"},{"location":"services/redisdb/","title":"RedisDB","text":"<p>For RedisDB you only need a <code>docker-compose.yaml</code>:</p> <pre><code>version: '3.9'\n\nservices:\nredis:\nimage: redis\nrestart: always\ncommand: \"redis-server --appendonly yes\"\nvolumes:\n- \"/srv/redis:/data\"\nnetworks:\n- database\nnetworks:\ndatabase:\nname: database\nexternal: true\n</code></pre> <p>That's it.</p>"},{"location":"services/vaultwarden/","title":"Vaultwarden","text":"<p>Create your <code>docker-compose.yaml</code>:</p> <pre><code>version: '3.9'\nservices:\nvaultwarden:\nimage: vaultwarden/server:alpine\nrestart: always\nenv_file: .vaultwarden.env\nports:\n- \"[::1]:8003:80\"\n- \"[::1]:3012:3012\"\nvolumes:\n- \"/srv/vaultwarden:/data/\"\nnetworks:\n- database\nnetworks:\ndatabase:\nname: database\nexternal: true\n</code></pre> <p>Then create a <code>.env</code>-File:</p> <pre><code># .vaultwarden.env\nDOMAIN=https://vault.domain.tld/\nSIGNUPS_ALLOWED=false\nINVITATIONS_ALLOWED=false\nSHOW_PASSWORD_HINT=false\nDATABASE_URL=postgresql://&lt;user&gt;:&lt;password&gt;@postgres:5432/&lt;database&gt;\nADMIN_TOKEN=&lt;yoursecureadmintoken&gt;\nWEBSOCKET_ENABLED=true\n</code></pre> <p>Issue a certificate and create a VHosts-File like here. Your VHosts-File should look like this:</p> <pre><code># https://ssl-config.mozilla.org/#server=nginx&amp;version=1.17.7&amp;config=modern&amp;openssl=1.1.1d&amp;guideline=5.6\nserver {\nserver_name vault.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/&lt;username&gt;/.acme.sh/vault.domain.tld/fullchain.cer;\nssl_certificate_key /home/&lt;username&gt;/.acme.sh/vault.domain.tld/vault.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation / {\nproxy_pass http://[::1]:8003/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n\nlocation /notifications/hub/negotiate {\nproxy_pass http://[::1]:8003/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n\nlocation /notifications/hub {\nproxy_pass http://[::1]:3012/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n}\n</code></pre> <p>Now you may go to <code>https://vault.domain.tld/admin</code> and enter your admin secret. Here you can manage your Vaultwarden instance.</p>"},{"location":"services/your_spotify/","title":"Your Spotify","text":"<p>This is a little dashboard for your Spotify activity.</p>"},{"location":"services/your_spotify/#spotify","title":"Spotify","text":"<p>You have to create a application on the Spotify Developer Dashboard. Then click on this application and click the button <code>Edit Settings</code>. You have to insert in the input field for <code>Redirect URIs</code> your callback URI looking like <code>https://music.domain.tld/api/oauth/spotify/callback</code>. Reveal and copy your client secret and your client id.</p>"},{"location":"services/your_spotify/#docker","title":"Docker","text":"<p>You need a <code>docker-compose.yaml</code>. Here is a sample file for you:</p> <pre><code>version: '3.9'\n\nservices:\nyour-spotify-server:\nimage: yooooomi/your_spotify_server\nrestart: always\nports:\n- \"[::1]:8011:8080\"\nenvironment:\n- API_ENDPOINT=https://music.domain.tld/api\n- CLIENT_ENDPOINT=https://music.domain.tld\n- SPOTIFY_PUBLIC=&lt;spotify_public_key&gt;\n- SPOTIFY_SECRET=&lt;spotify_app_secret&gt;\n- CORS=all\n- MONGO_ENDPOINT=mongodb://your_spotify:&lt;secure_password&gt;@mongodb:27017/your_spotify?authSource=your_spotify\nnetworks:\n- database\nyour-spotify-web:\nimage: yooooomi/your_spotify_client\nrestart: always\nports:\n- \"[::1]:8010:3000\"\nenvironment:\n- API_ENDPOINT=https://music.domain.tld/api\n</code></pre>"},{"location":"services/your_spotify/#nginx","title":"Nginx","text":"<p>The <code>nginx</code>-configuration deviates a little bit from the sample config. You need two locations on one domain. Here is how to do it:</p> <pre><code>server {\nserver_name music.domain.tld;\nlisten 0.0.0.0:443 ssl http2;\n\nssl_certificate /home/felix/.acme.sh/music.domain.tld/fullchain.cer;\nssl_certificate_key /home/felix/.acme.sh/music.domain.tld/music.domain.tld.key;\nssl_session_timeout 1d;\nssl_session_cache shared:MozSSL:10m;  # about 40000 sessions\nssl_session_tickets off;\n\nssl_protocols TLSv1.3;\nssl_prefer_server_ciphers off;\n\n# HSTS (ngx_http_headers_module is required) (63072000 seconds)\nadd_header Strict-Transport-Security \"max-age=63072000\" always;\n\nssl_stapling on;\nssl_stapling_verify on;\n\nlocation / {\nproxy_pass http://[::1]:8010/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\nlocation /api/ {\nproxy_pass http://[::1]:8011/;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection 'upgrade';\nproxy_set_header X-Real-IP $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\nproxy_set_header Host $host;\nproxy_cache_bypass $http_upgrade;\n}\n}\n</code></pre> <p>Then create a DNS record and issue a certificate like here. Start your container and reload Nginx.</p>"}]}